package com.maddrobot.plugins.udm.gradle.manager.service

import com.google.gson.Gson
import com.google.gson.JsonArray
import com.google.gson.JsonObject
import com.google.gson.annotations.SerializedName
import com.intellij.openapi.application.ApplicationManager
import com.intellij.openapi.components.Service
import com.intellij.openapi.diagnostic.Logger
import com.intellij.openapi.project.Project
import com.maddrobot.plugins.udm.gradle.manager.model.VulnerabilityInfo
import com.maddrobot.plugins.udm.gradle.manager.model.VulnerabilitySeverity
import com.maddrobot.plugins.udm.setting.PackageFinderSettingState
import java.net.HttpURLConnection
import java.net.URI
import java.util.concurrent.ConcurrentHashMap

/**
 * Service for checking vulnerabilities in dependencies using OSV (Open Source Vulnerability) API
 * and optionally GitHub Advisory Database.
 *
 * Primary source: OSV API (free, no auth required)
 * Secondary source: GitHub Advisory Database (requires token)
 */
@Service(Service.Level.PROJECT)
class VulnerabilityService(private val project: Project) {

    private val log = Logger.getInstance(javaClass)
    private val gson = Gson()

    // OSV API endpoint
    private val OSV_API_URL = "https://api.osv.dev/v1/query"
    private val OSV_BATCH_API_URL = "https://api.osv.dev/v1/querybatch"

    // GitHub Advisory Database endpoint
    private val GITHUB_GRAPHQL_URL = "https://api.github.com/graphql"

    // Cache for vulnerability results
    private val vulnerabilityCache = ConcurrentHashMap<String, CachedVulnerability>()
    private val CACHE_TTL_MS = 3600_000L // 1 hour

    private data class CachedVulnerability(
        val vulnerabilities: List<VulnerabilityInfo>,
        val timestamp: Long
    )

    companion object {
        fun getInstance(project: Project): VulnerabilityService =
            project.getService(VulnerabilityService::class.java)
    }

    /**
     * Check vulnerabilities for a single dependency.
     * Uses async callback pattern for UI integration.
     *
     * @param groupId The dependency group ID (e.g., "org.apache.logging.log4j")
     * @param artifactId The artifact ID (e.g., "log4j-core")
     * @param version The version to check
     * @param ecosystem The package ecosystem ("Maven" or "npm")
     * @param callback Callback with vulnerability results
     */
    fun checkVulnerabilities(
        groupId: String,
        artifactId: String,
        version: String,
        ecosystem: String = "Maven",
        callback: (List<VulnerabilityInfo>) -> Unit
    ) {
        ApplicationManager.getApplication().executeOnPooledThread {
            val vulnerabilities = checkVulnerabilitiesSync(groupId, artifactId, version, ecosystem)
            ApplicationManager.getApplication().invokeLater {
                callback(vulnerabilities)
            }
        }
    }

    /**
     * Synchronously check vulnerabilities for a dependency.
     */
    fun checkVulnerabilitiesSync(
        groupId: String,
        artifactId: String,
        version: String,
        ecosystem: String = "Maven"
    ): List<VulnerabilityInfo> {
        val packageName = "$groupId:$artifactId"
        val cacheKey = "$packageName:$version:$ecosystem"

        // Check cache first
        val cached = vulnerabilityCache[cacheKey]
        if (cached != null && System.currentTimeMillis() - cached.timestamp < CACHE_TTL_MS) {
            return cached.vulnerabilities
        }

        val results = mutableListOf<VulnerabilityInfo>()

        // Query OSV API (always available)
        try {
            val osvResults = queryOsv(packageName, version, ecosystem)
            results.addAll(osvResults)
        } catch (e: Exception) {
            log.debug("OSV query failed for $packageName:$version: ${e.message}")
        }

        // Query GitHub Advisory if token is configured
        val settings = PackageFinderSettingState.getInstance()
        if (settings.githubToken?.isNotBlank() == true) {
            try {
                val githubResults = queryGitHubAdvisory(groupId, artifactId, version, settings.githubToken!!)
                // Merge results, deduplicating by CVE ID
                val existingCves = results.mapNotNull { it.cveId }.toSet()
                for (vuln in githubResults) {
                    if (vuln.cveId == null || vuln.cveId !in existingCves) {
                        results.add(vuln)
                    }
                }
            } catch (e: Exception) {
                log.debug("GitHub Advisory query failed for $packageName:$version: ${e.message}")
            }
        }

        // Cache results
        vulnerabilityCache[cacheKey] = CachedVulnerability(results, System.currentTimeMillis())

        return results
    }

    /**
     * Batch check vulnerabilities for multiple dependencies.
     *
     * @param dependencies List of (groupId, artifactId, version) triples
     * @param ecosystem The package ecosystem
     * @param callback Callback with map of package ID to vulnerabilities
     */
    fun batchCheck(
        dependencies: List<Triple<String, String, String>>,
        ecosystem: String = "Maven",
        callback: (Map<String, List<VulnerabilityInfo>>) -> Unit
    ) {
        ApplicationManager.getApplication().executeOnPooledThread {
            val results = batchCheckSync(dependencies, ecosystem)
            ApplicationManager.getApplication().invokeLater {
                callback(results)
            }
        }
    }

    /**
     * Synchronously batch check vulnerabilities.
     */
    fun batchCheckSync(
        dependencies: List<Triple<String, String, String>>,
        ecosystem: String = "Maven"
    ): Map<String, List<VulnerabilityInfo>> {
        val results = mutableMapOf<String, List<VulnerabilityInfo>>()

        // Check cache first
        val uncached = mutableListOf<Triple<String, String, String>>()
        for ((groupId, artifactId, version) in dependencies) {
            val packageName = "$groupId:$artifactId"
            val cacheKey = "$packageName:$version:$ecosystem"
            val cached = vulnerabilityCache[cacheKey]

            if (cached != null && System.currentTimeMillis() - cached.timestamp < CACHE_TTL_MS) {
                results[packageName] = cached.vulnerabilities
            } else {
                uncached.add(Triple(groupId, artifactId, version))
            }
        }

        // Query uncached dependencies via OSV batch API
        if (uncached.isNotEmpty()) {
            try {
                val batchResults = queryOsvBatch(uncached, ecosystem)
                for ((packageName, vulnerabilities) in batchResults) {
                    results[packageName] = vulnerabilities
                    // Cache individual results
                    val version = uncached.find { "${it.first}:${it.second}" == packageName }?.third ?: ""
                    val cacheKey = "$packageName:$version:$ecosystem"
                    vulnerabilityCache[cacheKey] = CachedVulnerability(vulnerabilities, System.currentTimeMillis())
                }
            } catch (e: Exception) {
                log.warn("OSV batch query failed: ${e.message}")
                // Fall back to individual queries
                for ((groupId, artifactId, version) in uncached) {
                    val packageName = "$groupId:$artifactId"
                    results[packageName] = checkVulnerabilitiesSync(groupId, artifactId, version, ecosystem)
                }
            }
        }

        return results
    }

    /**
     * Query OSV API for vulnerabilities.
     */
    private fun queryOsv(packageName: String, version: String, ecosystem: String): List<VulnerabilityInfo> {
        val requestBody = JsonObject().apply {
            add("package", JsonObject().apply {
                addProperty("name", packageName)
                addProperty("ecosystem", ecosystem)
            })
            addProperty("version", version)
        }

        val connection = URI.create(OSV_API_URL).toURL().openConnection() as HttpURLConnection
        connection.requestMethod = "POST"
        connection.doOutput = true
        connection.connectTimeout = 10_000
        connection.readTimeout = 10_000
        connection.setRequestProperty("Content-Type", "application/json")

        connection.outputStream.use { os ->
            os.write(gson.toJson(requestBody).toByteArray())
        }

        if (connection.responseCode != 200) {
            log.debug("OSV API returned ${connection.responseCode} for $packageName:$version")
            return emptyList()
        }

        val response = connection.inputStream.bufferedReader().readText()
        return parseOsvResponse(response)
    }

    /**
     * Query OSV batch API for multiple packages.
     */
    private fun queryOsvBatch(
        dependencies: List<Triple<String, String, String>>,
        ecosystem: String
    ): Map<String, List<VulnerabilityInfo>> {
        val queries = JsonArray()
        for ((groupId, artifactId, version) in dependencies) {
            queries.add(JsonObject().apply {
                add("package", JsonObject().apply {
                    addProperty("name", "$groupId:$artifactId")
                    addProperty("ecosystem", ecosystem)
                })
                addProperty("version", version)
            })
        }

        val requestBody = JsonObject().apply {
            add("queries", queries)
        }

        val connection = URI.create(OSV_BATCH_API_URL).toURL().openConnection() as HttpURLConnection
        connection.requestMethod = "POST"
        connection.doOutput = true
        connection.connectTimeout = 30_000
        connection.readTimeout = 30_000
        connection.setRequestProperty("Content-Type", "application/json")

        connection.outputStream.use { os ->
            os.write(gson.toJson(requestBody).toByteArray())
        }

        if (connection.responseCode != 200) {
            throw RuntimeException("OSV batch API returned ${connection.responseCode}")
        }

        val response = connection.inputStream.bufferedReader().readText()
        val json = gson.fromJson(response, JsonObject::class.java)
        val results = mutableMapOf<String, List<VulnerabilityInfo>>()

        val resultsArray = json.getAsJsonArray("results")
        if (resultsArray != null) {
            for (i in 0 until resultsArray.size()) {
                if (i >= dependencies.size) break

                val (groupId, artifactId, _) = dependencies[i]
                val packageName = "$groupId:$artifactId"

                val resultObj = resultsArray[i].asJsonObject
                val vulns = resultObj.getAsJsonArray("vulns")
                if (vulns != null) {
                    results[packageName] = parseOsvVulns(vulns)
                } else {
                    results[packageName] = emptyList()
                }
            }
        }

        return results
    }

    /**
     * Parse OSV API response.
     */
    private fun parseOsvResponse(response: String): List<VulnerabilityInfo> {
        val json = gson.fromJson(response, JsonObject::class.java)
        val vulns = json.getAsJsonArray("vulns") ?: return emptyList()
        return parseOsvVulns(vulns)
    }

    /**
     * Parse OSV vulnerability array.
     */
    private fun parseOsvVulns(vulns: JsonArray): List<VulnerabilityInfo> {
        val results = mutableListOf<VulnerabilityInfo>()

        for (vuln in vulns) {
            val vulnObj = vuln.asJsonObject

            val id = vulnObj.get("id")?.asString
            val summary = vulnObj.get("summary")?.asString
            val details = vulnObj.get("details")?.asString

            // Extract CVE ID from aliases if present
            var cveId: String? = null
            val aliases = vulnObj.getAsJsonArray("aliases")
            if (aliases != null) {
                for (alias in aliases) {
                    val aliasStr = alias.asString
                    if (aliasStr.startsWith("CVE-")) {
                        cveId = aliasStr
                        break
                    }
                }
            }

            // Extract severity
            val severity = extractOsvSeverity(vulnObj)

            // Extract affected versions and fix version
            val (affectedVersions, fixedVersion) = extractOsvAffectedInfo(vulnObj)

            // Build advisory URL
            val advisoryUrl = vulnObj.getAsJsonArray("references")
                ?.firstOrNull()
                ?.asJsonObject
                ?.get("url")
                ?.asString

            results.add(VulnerabilityInfo(
                cveId = cveId ?: id,
                severity = severity,
                description = summary ?: details,
                affectedVersions = affectedVersions,
                fixedVersion = fixedVersion,
                advisoryUrl = advisoryUrl
            ))
        }

        return results
    }

    /**
     * Extract severity from OSV vulnerability object.
     */
    private fun extractOsvSeverity(vulnObj: JsonObject): VulnerabilitySeverity {
        // Try severity array first
        val severityArray = vulnObj.getAsJsonArray("severity")
        if (severityArray != null && severityArray.size() > 0) {
            val severityObj = severityArray[0].asJsonObject
            val score = severityObj.get("score")?.asString
            if (score != null) {
                return cvssToSeverity(score.toDoubleOrNull() ?: 0.0)
            }
        }

        // Try database_specific severity
        val dbSpecific = vulnObj.getAsJsonObject("database_specific")
        if (dbSpecific != null) {
            val severityStr = dbSpecific.get("severity")?.asString
            if (severityStr != null) {
                return stringToSeverity(severityStr)
            }
        }

        return VulnerabilitySeverity.UNKNOWN
    }

    /**
     * Extract affected versions and fix version from OSV vulnerability.
     */
    private fun extractOsvAffectedInfo(vulnObj: JsonObject): Pair<String?, String?> {
        val affected = vulnObj.getAsJsonArray("affected")
        if (affected == null || affected.size() == 0) return Pair(null, null)

        val affectedObj = affected[0].asJsonObject
        val ranges = affectedObj.getAsJsonArray("ranges")

        if (ranges != null && ranges.size() > 0) {
            val range = ranges[0].asJsonObject
            val events = range.getAsJsonArray("events")

            var introduced: String? = null
            var fixed: String? = null

            if (events != null) {
                for (event in events) {
                    val eventObj = event.asJsonObject
                    if (eventObj.has("introduced")) {
                        introduced = eventObj.get("introduced").asString
                    }
                    if (eventObj.has("fixed")) {
                        fixed = eventObj.get("fixed").asString
                    }
                }
            }

            val affectedStr = if (introduced != null && fixed != null) {
                "$introduced - $fixed"
            } else if (introduced != null) {
                ">= $introduced"
            } else {
                null
            }

            return Pair(affectedStr, fixed)
        }

        return Pair(null, null)
    }

    /**
     * Query GitHub Advisory Database (requires token).
     */
    private fun queryGitHubAdvisory(
        groupId: String,
        artifactId: String,
        version: String,
        token: String
    ): List<VulnerabilityInfo> {
        val query = """
            query {
                securityVulnerabilities(
                    first: 10,
                    ecosystem: MAVEN,
                    package: "$groupId:$artifactId"
                ) {
                    nodes {
                        advisory {
                            ghsaId
                            summary
                            description
                            severity
                            cvss {
                                score
                            }
                            references {
                                url
                            }
                            identifiers {
                                type
                                value
                            }
                        }
                        vulnerableVersionRange
                        firstPatchedVersion {
                            identifier
                        }
                    }
                }
            }
        """.trimIndent()

        val requestBody = JsonObject().apply {
            addProperty("query", query)
        }

        val connection = URI.create(GITHUB_GRAPHQL_URL).toURL().openConnection() as HttpURLConnection
        connection.requestMethod = "POST"
        connection.doOutput = true
        connection.connectTimeout = 10_000
        connection.readTimeout = 10_000
        connection.setRequestProperty("Content-Type", "application/json")
        connection.setRequestProperty("Authorization", "Bearer $token")

        connection.outputStream.use { os ->
            os.write(gson.toJson(requestBody).toByteArray())
        }

        if (connection.responseCode != 200) {
            log.debug("GitHub Advisory API returned ${connection.responseCode}")
            return emptyList()
        }

        val response = connection.inputStream.bufferedReader().readText()
        return parseGitHubAdvisoryResponse(response, version)
    }

    /**
     * Parse GitHub Advisory response.
     */
    private fun parseGitHubAdvisoryResponse(response: String, version: String): List<VulnerabilityInfo> {
        val results = mutableListOf<VulnerabilityInfo>()
        val json = gson.fromJson(response, JsonObject::class.java)

        val data = json.getAsJsonObject("data") ?: return emptyList()
        val securityVulnerabilities = data.getAsJsonObject("securityVulnerabilities") ?: return emptyList()
        val nodes = securityVulnerabilities.getAsJsonArray("nodes") ?: return emptyList()

        for (node in nodes) {
            val nodeObj = node.asJsonObject
            val advisory = nodeObj.getAsJsonObject("advisory") ?: continue

            // Check if this version is affected
            val versionRange = nodeObj.get("vulnerableVersionRange")?.asString
            if (versionRange != null && !isVersionAffected(version, versionRange)) {
                continue
            }

            // Extract CVE ID
            var cveId: String? = null
            val identifiers = advisory.getAsJsonArray("identifiers")
            if (identifiers != null) {
                for (identifier in identifiers) {
                    val identObj = identifier.asJsonObject
                    if (identObj.get("type")?.asString == "CVE") {
                        cveId = identObj.get("value")?.asString
                        break
                    }
                }
            }
            if (cveId == null) {
                cveId = advisory.get("ghsaId")?.asString
            }

            val severityStr = advisory.get("severity")?.asString
            val severity = stringToSeverity(severityStr ?: "UNKNOWN")

            val summary = advisory.get("summary")?.asString

            val advisoryUrl = advisory.getAsJsonArray("references")
                ?.firstOrNull()
                ?.asJsonObject
                ?.get("url")
                ?.asString

            val firstPatched = nodeObj.getAsJsonObject("firstPatchedVersion")
                ?.get("identifier")
                ?.asString

            results.add(VulnerabilityInfo(
                cveId = cveId,
                severity = severity,
                description = summary,
                affectedVersions = versionRange,
                fixedVersion = firstPatched,
                advisoryUrl = advisoryUrl
            ))
        }

        return results
    }

    /**
     * Check if a version is affected by a version range.
     * Simple implementation - can be enhanced for more complex version comparisons.
     */
    private fun isVersionAffected(version: String, range: String): Boolean {
        // Basic implementation - check for common patterns
        // GitHub uses formats like "< 2.17.0", ">= 2.0.0, < 2.17.0"
        return true // For now, include all and let the display filter
    }

    /**
     * Convert CVSS score to severity enum.
     */
    private fun cvssToSeverity(score: Double): VulnerabilitySeverity {
        return when {
            score >= 9.0 -> VulnerabilitySeverity.CRITICAL
            score >= 7.0 -> VulnerabilitySeverity.HIGH
            score >= 4.0 -> VulnerabilitySeverity.MEDIUM
            score > 0 -> VulnerabilitySeverity.LOW
            else -> VulnerabilitySeverity.UNKNOWN
        }
    }

    /**
     * Convert severity string to enum.
     */
    private fun stringToSeverity(severity: String): VulnerabilitySeverity {
        return when (severity.uppercase()) {
            "CRITICAL" -> VulnerabilitySeverity.CRITICAL
            "HIGH" -> VulnerabilitySeverity.HIGH
            "MODERATE", "MEDIUM" -> VulnerabilitySeverity.MEDIUM
            "LOW" -> VulnerabilitySeverity.LOW
            else -> VulnerabilitySeverity.UNKNOWN
        }
    }

    /**
     * Clear the vulnerability cache.
     */
    fun clearCache() {
        vulnerabilityCache.clear()
    }

    /**
     * Get cache statistics for debugging.
     */
    fun getCacheStats(): Map<String, Any> {
        return mapOf(
            "size" to vulnerabilityCache.size,
            "entries" to vulnerabilityCache.keys.toList().take(20)
        )
    }
}
