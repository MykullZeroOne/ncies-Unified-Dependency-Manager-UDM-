package com.maddrobot.plugins.udm.gradle.manager.service

import com.intellij.openapi.command.WriteCommandAction
import com.intellij.openapi.components.Service
import com.intellij.openapi.diagnostic.Logger
import com.intellij.openapi.fileEditor.FileDocumentManager
import com.intellij.openapi.project.Project
import com.intellij.openapi.vfs.LocalFileSystem
import com.maddrobot.plugins.udm.gradle.manager.model.PackageMetadata
import com.maddrobot.plugins.udm.gradle.manager.model.UnifiedPackage
import com.maddrobot.plugins.udm.gradle.manager.model.VulnerabilityInfo

/**
 * Service for ignoring vulnerabilities by inserting formatted comments
 * above dependency declarations in build files (Gradle or Maven pom.xml).
 */
@Service(Service.Level.PROJECT)
class VulnerabilityIgnoreService(private val project: Project) {

    private val log = Logger.getInstance(javaClass)

    companion object {
        const val IGNORE_MARKER = "Vulnerability Ignored"

        fun getInstance(project: Project): VulnerabilityIgnoreService {
            return project.getService(VulnerabilityIgnoreService::class.java)
        }
    }

    /**
     * Insert a vulnerability ignore comment above the dependency in the build file.
     * @return true if the comment was successfully inserted, false otherwise
     */
    fun ignoreVulnerability(pkg: UnifiedPackage, vulnInfo: VulnerabilityInfo, reason: String): Boolean {
        val (buildFilePath, offset) = getBuildFileAndOffset(pkg) ?: run {
            log.warn("Cannot ignore vulnerability: no build file info for package ${pkg.id}")
            return false
        }

        val virtualFile = LocalFileSystem.getInstance().findFileByPath(buildFilePath) ?: run {
            log.warn("Cannot ignore vulnerability: build file not found at $buildFilePath")
            return false
        }
        val document = FileDocumentManager.getInstance().getDocument(virtualFile) ?: run {
            log.warn("Cannot ignore vulnerability: could not get document for $buildFilePath")
            return false
        }
        val text = document.text

        val isXml = buildFilePath.endsWith(".xml") || buildFilePath.endsWith(".pom")
        val comment = generateIgnoreComment(vulnInfo, reason, isXml)

        // Find the start of the line containing the dependency
        val lineStart = findLineStart(text, offset)

        // Detect indentation from line start (scan forward to first non-whitespace)
        val indent = text.substring(lineStart).takeWhile { it == ' ' || it == '\t' }

        // Build the indented comment with trailing newline to separate from dependency
        val indentedComment = indentComment(comment, indent) + "\n"

        val sb = StringBuilder(text)
        sb.insert(lineStart, indentedComment)

        WriteCommandAction.runWriteCommandAction(project, "Ignore Vulnerability", null, {
            document.setText(sb.toString())
        })

        log.info("Inserted vulnerability ignore comment for ${pkg.id} (${vulnInfo.cveId}) in $buildFilePath")
        return true
    }

    /**
     * Check if a dependency at the given offset in the given file already has an ignore comment.
     * Looks backward from the dependency offset for the "Vulnerability Ignored" marker.
     * Ensures the ignore comment is directly above the dependency (only whitespace/blank lines
     * and comment-end markers between them, with no intervening code).
     */
    fun isVulnerabilityIgnored(buildFilePath: String, offset: Int): Boolean {
        val virtualFile = LocalFileSystem.getInstance().findFileByPath(buildFilePath) ?: return false
        val document = FileDocumentManager.getInstance().getDocument(virtualFile) ?: return false
        val text = document.text

        // Look at up to 800 chars before the offset for the ignore marker
        val safeOffset = minOf(offset, text.length)
        val searchStart = maxOf(0, safeOffset - 800)
        val textBefore = text.substring(searchStart, safeOffset)

        // Find the last occurrence of the ignore marker before this dependency
        val markerIndex = textBefore.lastIndexOf(IGNORE_MARKER)
        if (markerIndex == -1) return false

        val afterMarker = textBefore.substring(markerIndex)

        // Find the end of the comment block containing the marker
        val commentEndIndex = when {
            afterMarker.contains("*/") -> afterMarker.indexOf("*/") + 2
            afterMarker.contains("-->") -> {
                // For XML, find the last --> (the border line may also use -->)
                val lastCloseComment = afterMarker.lastIndexOf("-->")
                if (lastCloseComment >= 0) lastCloseComment + 3 else return false
            }
            else -> return false // Malformed comment
        }

        // The text between the end of the comment block and the dependency line
        val betweenText = afterMarker.substring(commentEndIndex)

        // Allow only whitespace, newlines, and additional XML/Gradle comment lines
        // (e.g., the "<!-- ==== -->" border line) between the comment and the dependency
        val trimmed = betweenText.trim()
        if (trimmed.isEmpty()) return true

        // If there's non-comment content between the ignore comment and the dependency,
        // it belongs to a different dependency
        val lines = trimmed.lines()
        return lines.all { line ->
            val stripped = line.trim()
            stripped.isEmpty() ||
                stripped.startsWith("<!--") && stripped.endsWith("-->") ||
                stripped.startsWith("//") ||
                stripped.startsWith("*") ||
                stripped.startsWith("/*") ||
                stripped == "*/"
        }
    }

    /**
     * Check if a package's vulnerability is ignored based on its metadata.
     */
    fun isPackageVulnerabilityIgnored(pkg: UnifiedPackage): Boolean {
        val (buildFilePath, offset) = getBuildFileAndOffset(pkg) ?: return false
        return isVulnerabilityIgnored(buildFilePath, offset)
    }

    /**
     * Extract build file path and offset from a package's metadata.
     */
    private fun getBuildFileAndOffset(pkg: UnifiedPackage): Pair<String, Int>? {
        return when (val metadata = pkg.metadata) {
            is PackageMetadata.GradleMetadata -> Pair(metadata.buildFile, metadata.offset)
            is PackageMetadata.MavenInstalledMetadata -> Pair(metadata.pomFile, metadata.offset)
            is PackageMetadata.GradlePluginMetadata -> Pair(metadata.buildFile, metadata.offset)
            is PackageMetadata.MavenPluginMetadata -> Pair(metadata.pomFile, metadata.offset)
            else -> null
        }
    }

    /**
     * Generate the ignore comment text.
     * For Gradle files: block comment (/* ... */) followed by //noinspection to suppress IDE inspection
     * For Maven/XML files: XML comment (<!-- ... -->) followed by <!--suppress --> to suppress IDE inspection
     */
    private fun generateIgnoreComment(vulnInfo: VulnerabilityInfo, reason: String, isXml: Boolean): String {
        val cveId = vulnInfo.cveId ?: "N/A"
        val severity = vulnInfo.severity.name
        val description = vulnInfo.description ?: "N/A"

        return if (isXml) {
            // XML comment for pom.xml
            buildString {
                appendLine("<!-- ================= $IGNORE_MARKER ================== -->")
                appendLine("<!-- Vulnerability details:")
                appendLine("         Vulnerability Key/ID: $cveId")
                appendLine("         Vulnerability type: $severity")
                appendLine("         Vulnerability description: $description")
                appendLine("     Comment: $reason -->")
                appendLine("<!-- ========================================================== -->")
                appendLine("<!--suppress VulnerableLibrariesLocal -->")
            }
        } else {
            // Block comment for Gradle (Kotlin DSL / Groovy)
            buildString {
                appendLine("/*")
                appendLine("$IGNORE_MARKER")
                appendLine("vulnerability details:")
                appendLine("    vulnerability Key/ID: $cveId")
                appendLine("    vulnerability type: $severity")
                appendLine("    vulnerability description: $description")
                appendLine("Comment: $reason")
                appendLine("*/")
                appendLine("//noinspection VulnerableLibrariesLocal")
            }
        }
    }

    /**
     * Find the start of the line containing the given offset.
     */
    private fun findLineStart(text: String, offset: Int): Int {
        var i = minOf(offset, text.length) - 1
        while (i >= 0 && text[i] != '\n') {
            i--
        }
        return i + 1
    }

    /**
     * Indent each line of the comment with the given indentation string.
     */
    private fun indentComment(comment: String, indent: String): String {
        return comment.lines().joinToString("\n") { line ->
            if (line.isBlank()) line else "$indent$line"
        }
    }
}
